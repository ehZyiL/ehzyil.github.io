







## WEB三大组件之Filter

### 1.**Filter 基础知识点**

![2390bd7b541b99100b29a.png](https://i3.wp.com/telegra.ph/file/2390bd7b541b99100b29a.png)

Filter 称为过滤器，主要用来拦截 http 请求，做一些其他的事情

**流程说明**

一个 http 请求过来之后:

- 首先进入 filter，执行相关业务逻辑
- 若判定通行，则进入 Servlet 逻辑，Servlet 执行完毕之后，又返回 Filter，最后在返回给请求方

- 判定失败，直接返回，不需要将请求发给 Servlet

**应用场景**

通过上面的流程，可以推算下具体的使用场景：

- 在 filter 层，来获取用户的身份
- 可以考虑在 filter 层做一些常规的校验（如参数校验，referer 校验、权限控制等）
- 可以在 filter 层做运维、安全防护相关的工作（如全链路打点，可以在 filter 层分配一个 traceId；也可以在这一层做限流等）

### 2.使用说明

filter 的基本使用比较简单，实现 Fitler 接口即可，如

````java
@Slf4j
@WebFilter(urlPatterns = "/*", filterName = "reqRecordFilter", asyncSupported = true)
public class ReqRecordFilter implements Filter {
    private static Logger REQ_LOG = LoggerFactory.getLogger("req");

    @Autowired
    private GlobalInitService globalInitService;

    @Autowired
    private StatisticsSettingService statisticsSettingService;

    @Override
    public void init(FilterConfig filterConfig) {
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        long start = System.currentTimeMillis();
        HttpServletRequest request = null;
        try {
            request = this.initReqInfo((HttpServletRequest) servletRequest);
            CrossUtil.buildCors(request, (HttpServletResponse) servletResponse);
            filterChain.doFilter(request, servletResponse);
        } finally {
            buildRequestLog(ReqInfoContext.getReqInfo(), request, System.currentTimeMillis() - start);
            ReqInfoContext.clear();
        }
    }

    @Override
    public void destroy() {
    }

    // ... 省略
}
````

上面有三个方法:

- 
  init: 初始化时执行

- destory: 销毁时执行

- doFilter: 重点关注这个，filter 规则命中的请求，都会走进来 

  三个参数，注意第三个 FilterChain，这里是经典的责任链设计模式

  执行 filterChain.doFilter(servletRequest, servletResponse) 表示会继续将请求执行下去；若不执行这一句，表示这一次的 http 请求到此为止了，后面的走不下去了

###  3.filter 注册

过滤器注册到 Spring 容器有多种使用姿势，除了上面技术派中使用的@WebFilter之外还有其他几种使用姿势，下面逐一进行介绍

**3.1 WebFilter 注解**(自定义Filter的实现)

使用 WebFilter 注解，标注到自己实现的过滤器上，其中有几个参数需要注意

WebFilter 常用属性如下，其中urlPatterns最为常用，表示这个 filter 适用于哪些 url 请求（默认场景下全部请求都被拦截）

**使用这个注解时，请注意，需要在启动类/配置类上添加@ServletComponentScan注解来启用**



**3.2 FilterRegistrationBean**(注册生效)

上面一种方式比较简单，但是再指定 Filter 的优先级比较麻烦，不如下面这种方式简单

```java
@Bean
public FilterRegistrationBean<Filter> orderFilter() {
    FilterRegistrationBean<Filter> filter = new FilterRegistrationBean<>();
    filter.setName("reqRecordFilter");
    filter.setUrlPatterns(Arrays.asList("/**"));
    filter.setFilter(new ReqRecordFilter());
    // 指定优先级
    filter.setOrder(-1);
    return filter;
}
```



**特别说明：@WebFilter  注解结合@Order  来定义 filter 注解，可能并不会生效**

@Order注解不能指定Filter优先级
@Order注解不能指定Filter优先级
@Order注解不能指定Filter优先级



## WEB三大组件之Servlet

Servlet的使用姿势，以及注册自定义的Servelt的四种姿势

1. @WebServlet 注解
2. ServletRegistrationBean bean定义
3. ServletContext 动态添加
4. 普通的spring bean模式





## 根据请求的跨域情况设置响应头部，以实现跨域资源共享。

```java
public class CrossUtil {
    /**
     * 支持跨域
     *
     * @param request
     * @param response
     */
    public static void buildCors(HttpServletRequest request, HttpServletResponse response) {
        String origin = request.getHeader("Origin");
        if (StringUtils.isBlank(origin)) {
            response.setHeader("Access-Control-Allow-Origin", "*");
            response.setHeader("Access-Control-Allow-Credentials", "false");
        } else {
            response.setHeader("Access-Control-Allow-Origin", origin);
            response.setHeader("Access-Control-Allow-Credentials", "true");
        }
        response.setHeader("Access-Control-Allow-Origin", request.getHeader("Origin"));
        response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE, HEAD");
        response.setHeader("Access-Control-Max-Age", "3600");
        response.setHeader("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept, X-Real-IP, X-Forwarded-For, d-uuid, User-Agent, x-zd-cs, Proxy-Client-IP, HTTP_CLIENT_IP, HTTP_X_FORWARDED_FOR");
    }
}
```



这段代码是一个用于构建CORS（跨源资源共享）的方法。CORS是一种浏览器机制，用于允许在一个域中加载来自另一个域的资源。该方法接收一个HttpServletRequest对象和一个HttpServletResponse对象作为参数。

首先，它从请求的头部获取"Origin"字段的值。如果该值为空或不存在，表示请求不是跨域请求，那么设置响应头部的"Access-Control-Allow-Origin"为"*"，表示允许来自任何域的请求。并且设置"Access-Control-Allow-Credentials"为"false"，表示不允许发送身份验证凭证。

如果"Origin"字段的值存在，表示请求是跨域请求，那么将"Access-Control-Allow-Origin"设置为该值，表示只允许来自该域的请求。并且设置"Access-Control-Allow-Credentials"为"true"，表示允许发送身份验证凭证。

然后，无论是跨域请求还是非跨域请求，都将"Access-Control-Allow-Origin"设置为请求头部的"Origin"字段的值。这是为了确保在跨域请求中，响应头部的"Access-Control-Allow-Origin"与请求头部的"Origin"值一致。

接下来，设置响应头部的"Access-Control-Allow-Methods"为"POST, GET, OPTIONS, PUT, DELETE, HEAD"，表示允许的请求方法。

然后，设置响应头部的"Access-Control-Max-Age"为"3600"，表示在接下来的3600秒内，不需要发送预检请求（preflight request）。

最后，设置响应头部的"Access-Control-Allow-Headers"为一系列允许的请求头部字段，包括"Origin, X-Requested-With, Content-Type, Accept, X-Real-IP, X-Forwarded-For, d-uuid, User-Agent, x-zd-cs, Proxy-Client-IP, HTTP_CLIENT_IP, HTTP_X_FORWARDED_FOR"。

总的来说，这段代码的作用是根据请求的跨域情况设置响应头部，以实现跨域资源共享。



### 使用方法

在使用拦截器的时候调用`CrossUtil.buildCors(request, (HttpServletResponse) servletResponse);`方法。

![a4479df81b999817c29d0.png](https://i3.wp.com/telegra.ph/file/a4479df81b999817c29d0.png)



## 如果在切面日志中通过 InputStream 中读取了参数打印，业务控制器中还能正确获得到参数吗？



**答案是:如果不做处理的话，读取不到。**

底层其实涉及到 Java 的输入输出流。当我们从输入流中读取数据时，实际上是在消耗数据，就像我们把水喝进肚子里一样。一旦数据被读取出来，就不能再次读取了。

从技术角度来看，当我们从输入流中读取数据时，读取的位置（通常称为“游标”或“指针”）会向前移动。当读完所有的数据后，游标就移到了流的末尾，所以不能再读取更多的数据了。

技术派已经做过这方面的处理了，答案就在 BodyReaderHttpServletRequestWrapper 类中，它继承了 HttpServletRequestWrapper，该包装类会读取并缓存请求 body。

HttpServletRequestWrapper 是一个实现了 HttpServletRequest 接口的类，它被设计成一个装饰器（Decorator）类，主要用于对  HttpServletRequest 对象进行包装，提供一种修改请求对象的方式.

HttpServletRequestWrapper 类的主要作用是在不修改原始请求对象的情况下，提供一种方式来修改请求中的信息，例如请求头或请求参数。 

技术派中的 BodyReaderHttpServletRequestWrapper 就是 HttpServletRequestWrapper 类的一个具体实现，主要用于读取和缓存 HTTP 请求的  body。 

我们来具体分析一下。

 1）构造方法，根据请求的内容类型和方法，读取并缓存请求 body。

```
    public BodyReaderHttpServletRequestWrapper(HttpServletRequest request) {
        super(request);

        if (POST_METHOD.contains(request.getMethod()) && !isMultipart(request) && !isBinaryContent(request) && !isFormPost(request)) {
            bodyString = getBodyString(request);
            body = bodyString.getBytes(StandardCharsets.UTF_8);
        } else {
            bodyString = null;
            body = null;
        }
    }
```



2）重写了 getReader 和 getInputStream 方法，使得每次调用都会返回一个新的输入流或读取器，指向同一个缓存的请求 body。这样，我们就可 以多次读取请求 body 了。

```
@Override
public BufferedReader getReader() throws IOException {
    return new BufferedReader(new InputStreamReader(getInputStream()));
}

@Override
public ServletInputStream getInputStream() throws IOException {
    if (body == null) {
        return super.getInputStream();
    }

    final ByteArrayInputStream bais = new ByteArrayInputStream(body);
    return new ServletInputStream() {
        @Override
        public int read() throws IOException {
            return bais.read();
        }

        @Override
        public boolean isFinished() {
            return false;
        }

        @Override
        public boolean isReady() {
            return true;
        }

        @Override
        public void setReadListener(ReadListener readListener) {
        }
    };
}
```

3）hasPayload 方法返回一个布尔值，表示是否存在请求 body。

```
public boolean hasPayload() {
    return bodyString != null;
}
```

4）getBodyString 方法返回缓存的请求 body。

```java
    private String getBodyString(HttpServletRequest request) {
        BufferedReader br;
        try {
            br = request.getReader();
        } catch (IOException e) {
            logger.warn("Failed to get reader", e);
            return "";
        }

        String str;
        StringBuilder body = new StringBuilder();
        try {
            while ((str = br.readLine()) != null) {
                body.append(str);
            }
        } catch (IOException e) {
            logger.warn("Failed to read line", e);
        }

        try {
            br.close();
        } catch (IOException e) {
            logger.warn("Failed to close reader", e);
        }

        return body.toString();
    }
```



全部代码：

```java
public class BodyReaderHttpServletRequestWrapper extends HttpServletRequestWrapper {
    private static final List<String> POST_METHOD = Arrays.asList("POST", "PUT");
    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    private final byte[] body;
    private final String bodyString;

    public BodyReaderHttpServletRequestWrapper(HttpServletRequest request) {
        super(request);

        if (POST_METHOD.contains(request.getMethod()) && !isMultipart(request) && !isBinaryContent(request) && !isFormPost(request)) {
            bodyString = getBodyString(request);
            body = bodyString.getBytes(StandardCharsets.UTF_8);
        } else {
            bodyString = null;
            body = null;
        }
    }

    @Override
    public BufferedReader getReader() throws IOException {
        return new BufferedReader(new InputStreamReader(getInputStream()));
    }

    @Override
    public ServletInputStream getInputStream() throws IOException {
        if (body == null) {
            return super.getInputStream();
        }

        final ByteArrayInputStream bais = new ByteArrayInputStream(body);
        return new ServletInputStream() {
            @Override
            public int read() throws IOException {
                return bais.read();
            }

            @Override
            public boolean isFinished() {
                return false;
            }

            @Override
            public boolean isReady() {
                return true;
            }

            @Override
            public void setReadListener(ReadListener readListener) {
            }
        };
    }

    public boolean hasPayload() {
        return bodyString != null;
    }

    public String getBodyString() {
        return bodyString;
    }

    private String getBodyString(HttpServletRequest request) {
        BufferedReader br;
        try {
            br = request.getReader();
        } catch (IOException e) {
            logger.warn("Failed to get reader", e);
            return "";
        }

        String str;
        StringBuilder body = new StringBuilder();
        try {
            while ((str = br.readLine()) != null) {
                body.append(str);
            }
        } catch (IOException e) {
            logger.warn("Failed to read line", e);
        }

        try {
            br.close();
        } catch (IOException e) {
            logger.warn("Failed to close reader", e);
        }

        return body.toString();
    }

    /**
     * is binary content
     *
     * @param request http request
     * @return ret
     */
    private boolean isBinaryContent(final HttpServletRequest request) {
        return request.getContentType() != null &&
                (request.getContentType().startsWith("image") || request.getContentType().startsWith("video") ||
                        request.getContentType().startsWith("audio"));
    }

    /**
     * is multipart content
     *
     * @param request http request
     * @return ret
     */
    private boolean isMultipart(final HttpServletRequest request) {
        return request.getContentType() != null && request.getContentType().startsWith("multipart/form-data");
    }

    private boolean isFormPost(final HttpServletRequest request) {
        return request.getContentType() != null && request.getContentType().startsWith("application/x-www-form-urlencoded");
    }
}

```



### 使用方法

![f4205f1565150fc575781.png](https://i3.wp.com/telegra.ph/file/f4205f1565150fc575781.png)

![4455cb138b63d18ccb204.png](https://i3.wp.com/telegra.ph/file/4455cb138b63d18ccb204.png)

![47510fcbf5c16b645bc05.png](https://i3.wp.com/telegra.ph/file/47510fcbf5c16b645bc05.png)



## **Filter实现请求日志记录**

 **技术方案** 

如果单纯的将这个记录接口的请求信息，当作一个普通的需求来设计，我们可以怎么来实现呢？

- 基于过滤器Filter，来拦截web请求，记录请求相关信息
- 基于AOP来实现方法拦截，借助@Around来实现请求方法执行前后增强，记录请求相关信息



那么两个方案如何选择呢？

 **Filter过滤器方案** 

若使用过滤器，则主要就是拦截web请求了，具体的实现流程如

![2d62bb9a144a7b2482fc1.png](https://i3.wp.com/telegra.ph/file/2d62bb9a144a7b2482fc1.png)

在过滤器的doFilter方法中，划分为三块：

doBefore: 表示将请求转发到Controller执行之前 

- ​	记录开始执行时间
- ​	记录请求相关信息

doFilter: 即将请求转发到Controller去执行

doAfter: Controller方法执行完 

- 记录结束时间，计算执行耗时
- 日志输出

使用这种方式的优缺点比较突出，优点是适用性强，实现简单，缺点是只能记录Controller的请求相关信息，如果我们想统计某个Service方法、Mapper方法，那么这种方式则不太合适

 **AOP切面方案** 

若使用AOP来实现，则关键点在于我需要拦截哪些方法，即定义切点

![656c63558d664467d4231.png](https://i3.wp.com/telegra.ph/file/656c63558d664467d4231.png)

基本策略与前面差不多，不过有几个关键点

- 定义切点：可以是直接拦截包路径方式，也可以配合自定义注解，拦截某些特定注解的方法
- 使用Around环绕方式



使用AOP来实现的优缺点也比较明显

优点：灵活性非常高，可以拦截任何共有方法

缺点：需要自定义切点，通常不太容易一次编写，所有项目适用



 **选型** 这篇教程，主要介绍的是基于Filter来实现请求信息的记录；

```
@Slf4j
@WebFilter(urlPatterns = "/*", filterName = "reqRecordFilter", asyncSupported = true)
public class ReqRecordFilter implements Filter {
    private static Logger REQ_LOG = LoggerFactory.getLogger("req");
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        long start = System.currentTimeMillis();
        HttpServletRequest request = null;
        try {
            // 构建请求上下文
            request = this.initReqInfo((HttpServletRequest) servletRequest);
            filterChain.doFilter(request, servletResponse);
        } finally {
            // 根据请求上下文，输出请求日志
            buildRequestLog(ReqInfoContext.getReqInfo(), request, System.currentTimeMillis() - start);
            ReqInfoContext.clear();
        }
    }

    private HttpServletRequest initReqInfo(HttpServletRequest request) {
        if (staticURI(request)) {
            // 静态资源直接放行
            return request;
        }

        try {
            ReqInfoContext.ReqInfo reqInfo = new ReqInfoContext.ReqInfo();
            reqInfo.setHost(request.getHeader("host"));
            reqInfo.setPath(request.getPathInfo());
            reqInfo.setReferer(request.getHeader("referer"));
            reqInfo.setClientIp(IpUtil.getClientIp(request));
            reqInfo.setUserAgent(request.getHeader("User-Agent"));

            request = this.wrapperRequest(request, reqInfo);
            ReqInfoContext.addReqInfo(reqInfo);
        } catch (Exception e) {
            log.error("init reqInfo error!", e);
        }

        return request;
    }
    
    private HttpServletRequest wrapperRequest(HttpServletRequest request, ReqInfoContext.ReqInfo reqInfo) {
        if (!HttpMethod.POST.name().equalsIgnoreCase(request.getMethod())) {
            return request;
        }

        // 封装请求参数
        BodyReaderHttpServletRequestWrapper requestWrapper = new BodyReaderHttpServletRequestWrapper(request);
        reqInfo.setPayload(requestWrapper.getBodyString());
        return requestWrapper;
    }

    private void buildRequestLog(ReqInfoContext.ReqInfo req, HttpServletRequest request, long costTime) {
        if (req == null || staticURI(request)) {
            return;
        }

        StringBuilder msg = new StringBuilder();
        msg.append("method=").append(request.getMethod()).append("; ");
        if (StringUtils.isNotBlank(req.getReferer())) {
            msg.append("referer=").append(URLDecoder.decode(req.getReferer())).append("; ");
        }
        msg.append("remoteIp=").append(req.getClientIp());
        msg.append("; agent=").append(req.getUserAgent());

        if (req.getUserId() != null) {
            // 打印用户信息
            msg.append("; user=").append(req.getUserId());
        }

        msg.append("; uri=").append(request.getRequestURI());
        if (StringUtils.isNotBlank(request.getQueryString())) {
            msg.append('?').append(URLDecoder.decode(request.getQueryString()));
        }

        msg.append("; payload=").append(req.getPayload());
        msg.append("; cost=").append(costTime);
        REQ_LOG.info("{}", msg);

        // 保存请求计数
        statisticsSettingService.saveRequestCount(req.getClientIp());
    }
    
    private  boolean staticURI(HttpServletRequest request) {
        return request == null
                || request.getRequestURI().endsWith("css")
                || request.getRequestURI().endsWith("js")
                || request.getRequestURI().endsWith("png")
                || request.getRequestURI().endsWith("ico")
                || request.getRequestURI().endsWith("svg");
    }
}
```



**排除静态资源**
主要是基于request.getRequestURI() 后缀来进行过滤的

```
private  boolean staticURI(HttpServletRequest request) {
    return request == null
            || request.getRequestURI().endsWith("css")
            || request.getRequestURI().endsWith("js")
            || request.getRequestURI().endsWith("png")
            || request.getRequestURI().endsWith("ico")
            || request.getRequestURI().endsWith("svg");
}
```

上面这种方式虽然实现简单，但是有缺陷：

- 如静态资源请求待url参数
- 如除了上面几种类型之外的静态资源（xml、MP3等）



**请求上下文**

接下来看一下请求上下文的构建，主要是基于HttpServletRequest来获取相关参数

 

```
private HttpServletRequest initReqInfo(HttpServletRequest request) {
    if (staticURI(request)) {
        // 静态资源直接放行
        return request;
    }

    try {
        ReqInfoContext.ReqInfo reqInfo = new ReqInfoContext.ReqInfo();
        reqInfo.setHost(request.getHeader("host"));
        reqInfo.setPath(request.getPathInfo());
        reqInfo.setReferer(request.getHeader("referer"));
        reqInfo.setClientIp(IpUtil.getClientIp(request));
        reqInfo.setUserAgent(request.getHeader("User-Agent"));

        // 传参的封装处理：主要是为了避免post的输入流，读取一次之后无法再次读取的问题
        request = this.wrapperRequest(request, reqInfo);
        
        ReqInfoContext.addReqInfo(reqInfo);
    } catch (Exception e) {
        log.error("init reqInfo error!", e);
    }

    return request;
}
```



**重点关注两个：**

1.请求者的ip获取

核心实现如下（通用的工具类，需要注意的是若使用nginx做反向代理，那么请不要将用户的请求信息给吃掉了，否则下面这个方法拿不到）

```
/**
 * 获取请求来源的ip地址
 *
 * @param request
 * @return
 */
public static String getClientIp(HttpServletRequest request) {
    try {
        String xIp = request.getHeader("X-Real-IP");
        String xFor = request.getHeader("X-Forwarded-For");
        if (StringUtils.isNotEmpty(xFor) && !UNKNOWN.equalsIgnoreCase(xFor)) {
            //多次反向代理后会有多个ip值，第一个ip才是真实ip
            int index = xFor.indexOf(",");
            if (index != -1) {
                return xFor.substring(0, index);
            } else {
                return xFor;
            }
        }
        xFor = xIp;
        if (StringUtils.isNotEmpty(xFor) && !UNKNOWN.equalsIgnoreCase(xFor)) {
            return xFor;
        }
        if (StringUtils.isBlank(xFor) || UNKNOWN.equalsIgnoreCase(xFor)) {
            xFor = request.getHeader("Proxy-Client-IP");
        }
        if (StringUtils.isBlank(xFor) || UNKNOWN.equalsIgnoreCase(xFor)) {
            xFor = request.getHeader("WL-Proxy-Client-IP");
        }
        if (StringUtils.isBlank(xFor) || UNKNOWN.equalsIgnoreCase(xFor)) {
            xFor = request.getHeader("HTTP_CLIENT_IP");
        }
        if (StringUtils.isBlank(xFor) || UNKNOWN.equalsIgnoreCase(xFor)) {
            xFor = request.getHeader("HTTP_X_FORWARDED_FOR");
        }
        if (StringUtils.isBlank(xFor) || UNKNOWN.equalsIgnoreCase(xFor)) {
            xFor = request.getRemoteAddr();
        }

        if ("localhost".equalsIgnoreCase(xFor) || "127.0.0.1".equalsIgnoreCase(xFor) || "0:0:0:0:0:0:0:1".equalsIgnoreCase(xFor)) {
            return getLocalIp4Address();
        }
        return xFor;
    } catch (Exception e) {
        log.error("get remote ip error!", e);
        return "x.0.0.1";
    }
}
```



**请求参数封装**
首先需要理解一下，为啥要封装请求参数？
对于post之类的请求，若传参是json，那么需要从HttpServletRequest的请求流中读取，但是这个流是一次性的，如果打印日志的时候把这个参数读取出来了，那么在实际的业务中，就拿不到对应的参数了
为了解决这个问题，我们需要将这个InputStream进行封装一下，所以技术派定义了一个BodyReaderHttpServletRequestWrapper 类，来封装一下请求

详细代码见

**如果在切面日志中通过 InputStream 中读取了参数打印，业务控制器中还能正确获得到参数吗？**



核心实现如下

1. 只拿post,put请求，非二进制、非文件上传、非表单数据上传的场景

2. 将请求参数读取到 byte[] body

3. 基于body封装ServletInputStream，用于后续的传参获取

   

**日志输出**
最后在看一下日志输出，我们直接将上面封装的请求相关信息，按照具体的日志输出格式进行打印

```
private void buildRequestLog(ReqInfoContext.ReqInfo req, HttpServletRequest request, long costTime) {
    if (req == null || staticURI(request)) {
        return;
    }

    StringBuilder msg = new StringBuilder();
    msg.append("method=").append(request.getMethod()).append("; ");
    if (StringUtils.isNotBlank(req.getReferer())) {
        msg.append("referer=").append(URLDecoder.decode(req.getReferer())).append("; ");
    }
    msg.append("remoteIp=").append(req.getClientIp());
    msg.append("; agent=").append(req.getUserAgent());

    if (req.getUserId() != null) {
        // 打印用户信息
        msg.append("; user=").append(req.getUserId());
    }

    msg.append("; uri=").append(request.getRequestURI());
    if (StringUtils.isNotBlank(request.getQueryString())) {
        msg.append('?').append(URLDecoder.decode(request.getQueryString()));
    }

    msg.append("; payload=").append(req.getPayload());
    msg.append("; cost=").append(costTime);
    REQ_LOG.info("{}", msg);
}
```









## 配置日志之整合logback



对于一个后端来说，日志是不可缺少的，一个项目中很多地方需要用到日志，比如业务节点日志，比如外部请求相关日志，比如基于日志的异常报警等本文主要就是记录在项目中集成日志框架，怎么在实际的业务代码中使用日志，主要的知识点将包含以下几点：

- 日志级别选择
- 日志输出到文件
- 格式化输出
- 日志文件管理（自动删除，压缩归档等）
- 常用的logback-spring.xml配置



### logback.xml日志配置

1.配置文件名：**logback-spring.xml**

```
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- fixme 知识点：logback配置变量的姿势，如何读取Spring配置参数   -->
    <springProperty scope="context" name="log.path" source="log.path" defaultValue="logs"/>
    <springProperty scope="context" name="log.env" source="env.name" defaultValue="NO"/>
    <property name="log.service.name" value="blog"/>
    <property name="log.req.name" value="req"/>


    <!-- %m输出的信息,%p日志级别,%t线程名,%d日期,%c类的全名,%i索引【从数字0开始递增】,,, -->
    <!-- appender是configuration的子节点，是负责写日志的组件。 -->
    <!-- ConsoleAppender：把日志输出到控制台 -->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d [%t] %-5level|%mdc{traceId}|%mdc{bizCode}|%logger{36}.%M\(%file:%line\) - %msg%n</pattern>
            <!-- 控制台也要使用UTF-8，不要使用GBK，否则会中文乱码 -->
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- 当出现error异常日志时，邮件报警   -->
    <appender name="errorAlarm" class="com.ehzyil.utils.AlarmUtil">
        <!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter-->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>ERROR</level>
        </filter>
    </appender>

    <!-- RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 -->
    <!-- 以下的大概意思是：1.先按日期存日志，日期变了，将前一天的日志文件名重命名为XXX%日期%索引，新的日志仍然是demo.log -->
    <!--             2.如果日期没有发生变化，但是当前日志的文件大小超过1KB时，对当前日志进行分割 重命名-->
    <appender name="service" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter-->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>INFO</level>
        </filter>
        <File>${log.path}/${log.service.name}-${log.env}.log</File>
        <!-- rollingPolicy:当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。 -->
        <!-- TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 活动文件的名字会根据fileNamePattern的值，每隔一段时间改变一次 -->
            <!-- 定义归档文件名 -->
            <fileNamePattern>${log.path}/arch/${log.service.name}-${log.env}.%d.%i.log</fileNamePattern>
            <!-- 每产生一个日志文件，该日志文件的保存期限为3天 -->
            <maxHistory>3</maxHistory>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <!-- maxFileSize:这是活动文件的大小，默认值是10MB，测试时可改成1KB看效果 -->
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <encoder>
            <!-- pattern节点，用来设置日志的输入格式 -->
            <pattern>
                [%d{yyyy-MM-dd HH:mm:ss}]|%mdc{traceId}|%mdc{bizCode}|{"logger":"%logger{36}", "thread":"%thread", "msg":"%msg"}%n
            </pattern>
            <!-- 记录日志的编码:此处设置字符集 - -->
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!--  请求日志 -->
    <appender name="reqLog" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <File>${log.path}/${log.req.name}-${log.env}.log</File>
        <!--滚动策略，按照时间滚动 TimeBasedRollingPolicy-->
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间-->
            <FileNamePattern>${log.path}/arch/req/req.%d{yyyy-MM-dd}.%i.log.gz</FileNamePattern>
            <!-- 单个日志文件最多 100MB -->
            <maxFileSize>100MB</maxFileSize>
            <!--只保留最近10天的日志-->
            <maxHistory>10</maxHistory>
            <!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志-->
<!--            <totalSizeCap>1GB</totalSizeCap>   -->
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
        <!--日志输出编码格式化-->
        <encoder>
            <charset>UTF-8</charset>
            <pattern>[%d{yyyy-MM-dd HH:mm:ss}|%mdc{traceId}|] - %msg%n</pattern>
        </encoder>
    </appender>

    <logger name="req" level="info" additivity="false">
        <appender-ref ref="reqLog"/>
    </logger>


    <logger name="springfox.documentation.spring" level="warn" additivity="false">
        <appender-ref ref="STDOUT"/>
        <appender-ref ref="service"/>
    </logger>

    <!-- 指定项目中某个包，当有日志操作行为时的日志记录级别 -->
    <!-- 级别依次为【从高到低】：FATAL > ERROR > WARN > INFO > DEBUG > TRACE  -->
    <!-- additivity=false 表示匹配之后，不再继续传递给其他的logger-->
    <logger name="com.ehzyil" level="INFO" additivity="false">
        <appender-ref ref="service"/>
        <appender-ref ref="STDOUT"/>
        <appender-ref ref="errorAlarm"/>
    </logger>

    <!-- 控制台输出日志级别 -->
    <root level="INFO">
        <appender-ref ref="STDOUT"/>
        <appender-ref ref="service"/>
    </root>
</configuration>
```

2.**属性参数**
上面的配置文件中开头就有四个配置参数

```
    <springProperty scope="context" name="log.path" source="log.path" defaultValue="logs"/>
    <springProperty scope="context" name="log.env" source="env.name" defaultValue="NO"/>
    <property name="log.service.name" value="blog"/>
    <property name="log.req.name" value="req"/>
```

springProperty: 表示这里定义的参数，从Spring的配置中获取，如 log.path 拿的就是Spring配置文件中的配置log.path值

dev与prod的日志存储路径不同，本地开发时，日志文件放在项目目录下；生成环境 部署时，放在确定的目录下



**property**: 这个则是定义日志文件参数，供日志配置文件实际使用
使用姿势：

```
${配置名}
```

3.**appender**
在前面的配置文件中，appender这个标签算是比较重要的，上面定义了两类，一个控制台输出，一个文件输出
控制台or文件的选择
appender的class属性来选择

- 控制台： ch.qos.logback.core.ConsoleAppender

- 滚动时间窗口文件：ch.qos.logback.core.rolling.RollingFileAppender

**输出格式**
以实例 <pattern>%d [%t] %-5level %logger{36}.%M\(%file:%line\) - %msg%n</pattern> 进行说明

- %m输出的信息,

- %p日志级别,

- %t线程名,

- %d日期,

- %c类的全名,

- %i索引【从数字0开始递增】

- %M方法名

- %lines输出日志的行数

- %F/%file源码文件名

日志归档相关
一般是每天归档一下日志文件，避免所有的日志都堆积到一个文件，当单文件特别大时，分析也不是一件容易的事情，常见的两个设置参数

```
<!-- 日志文件最多保存三天 -->
<maxHistory>3</maxHistory>
<timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
    <!-- maxFileSize:这是活动文件的大小，默认值是10MB，测试时可改成1KB看效果 -->
    <maxFileSize>10MB</maxFileSize>
</timeBasedFileNamingAndTriggeringPolicy>
```

4. **logger**
  另外一个标签就是logger了，name表示哪些包路径下的日志输出会匹配这个（或者logger直接使用了这个name，也会匹配他）
  另外两个重要的属性，level表示输出日志的级别，挺实用的，可以根据实际场景设置某些日志输出，如框架层我只关系WARN级别日志；我自己的业务可能就像关注INFO的日志了
  additivity 这个属性，很容易不设置，如果不设置，那么当一个日志输出，有多个logger匹配时，这个日志就会被输出多次，建议设置为false

5. **使用实例**
  使用姿势也没有什么特殊的，常见的四种级别

  log.debug: 调试

  log.info: 信息输出

  log.warn: 警告

  log.error: 错误

  

  需要重点关注的一点是，在输出debug日志时，推荐使用下面这种姿势 

```
if (log.isDebugEnabled()) {
    log.debug("输出debug日志");
}
```







### 异常日志报警通知

**设计思路**

接下来这个方案的主要出发点在于，当程序出现大量的异常，表明应用多半出现了问题，需要立马发送给项目owner

要实现这个方案，关键点就在于异常出现的感知与上报

- 异常的捕获，并输出日志（这个感觉属于标配了吧，别告诉我现在还有应用不输出日志文件的...） 对于这个感知，借助logback的扩展机制，可以实现，后面介绍
- 异常上报：邮件发送



关于email的使用姿势，推荐参考博文

 [SpringBoot 系列之邮件发送姿势介绍](https://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&mid=2247486591&idx=1&sn=04f18e2f313abd371947f9818e238067&chksm=fce717d3cb909ec575b8e521843eff04edfcf844e59ca976515bc29d8a23782c4d5d30580d0e&token=908878619&lang=zh_CN#rd) 

**自定义appender**

定义一个用于错误发送的Appender，如下

```
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.AppenderBase;

public class AlarmUtil extends AppenderBase<ILoggingEvent> {
    private static final long INTERVAL = 10 * 1000 * 60;
    private long lastAlarmTime = 0;

    @Override
    protected void append(ILoggingEvent iLoggingEvent) {
        if (canAlarm()) {
//            EmailUtil.sendMail(iLoggingEvent.getLoggerName(),
//                    SpringUtil.getConfig("alarm.user", "@163.com"),
//                    iLoggingEvent.getFormattedMessage());
        }
    }

    private boolean canAlarm() {
        // 做一个简单的频率过滤,一分钟内只允许发送一条报警
        long now = System.currentTimeMillis();
        if (now - lastAlarmTime >= INTERVAL) {
            lastAlarmTime = now;
            return true;
        } else {
            return false;
        }
    }
}
```

上面的实现做了一个简单的频率控制，后续可以考虑借助gauva的限流器来做实现频率管理

**logback配置**

接下来就是在日志配置中，使用我们上面定义的Appender

logback-spring.xml文件内容如下：

```
    <!-- 当出现error异常日志时，邮件报警   -->
    <appender name="errorAlarm" class="com.ehzyil.utils.AlarmUtil">
        <!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter-->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>ERROR</level>
        </filter>
    </appender>

    <!-- 指定项目中某个包，当有日志操作行为时的日志记录级别 -->
    <!-- 级别依次为【从高到低】：FATAL > ERROR > WARN > INFO > DEBUG > TRACE  -->
    <!-- additivity=false 表示匹配之后，不再继续传递给其他的logger-->
    <logger name="com.ehzyil" level="INFO" additivity="false">
        <appender-ref ref="service"/>
        <appender-ref ref="STDOUT"/>
        <appender-ref ref="errorAlarm"/>
    </logger>
```



## 全局异常处理

### HandlerExceptionResolver



HandlerExceptionResolver 是 Spring 提供的一种异常处理机制，它允许我们在应用程序中以统一的方式处理控制器方法引发的异常。

要使用 HandlerExceptionResolver，我们需要创建一个实现该接口的类，并在其中定义如何处理异常。例如：

```
@Slf4j
@Order(-100)
public class ForumExceptionHandler implements HandlerExceptionResolver {

    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
     }
```

@Slf4j 是 lombok 提供的一个日志注解。
@Order 注解用于指定 Spring 中组件的加载顺序。它接受一个整数值，数值越小，组件的优先级越高，加载顺序越靠前。
在 resolveException 方法中，我们可以自定义异常处理逻辑，根据异常类型返回不同的 ModelAndView。



我们来看一下 resolveException 方法中的具体写法：

```
Status errStatus = buildToastMsg(ex);

if (restResponse(request, response)) {
    // 表示返回json数据格式的异常提示信息
    if (response.isCommitted()) {
        // 如果返回已经提交过，直接退出即可
        return new ModelAndView();
    }

    try {
        response.reset();
        // 若是rest接口请求异常时，返回json格式的异常数据；而不是专门的500页面
        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);
        response.setHeader("Cache-Control", "no-cache, must-revalidate");
        response.getWriter().println(JsonUtil.toStr(ResVo.fail(errStatus)));
        response.getWriter().flush();
        response.getWriter().close();
        return new ModelAndView();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}

String view = getErrorPage(errStatus, response);
ModelAndView mv = new ModelAndView(view);
response.setContentType(MediaType.TEXT_HTML_VALUE);
mv.getModel().put("global", SpringUtil.getBean(GlobalInitService.class).globalAttr());
mv.getModel().put("res", ResVo.fail(errStatus));
mv.getModel().put("toast", JsonUtil.toStr(ResVo.fail(errStatus)));
return mv;
}
```



技术派做了两种处理，一种是 REST 接口请求的异常，一种是针对普通页面请求的异常。

①、如果是 REST 接口请求异常，代码会返回一个 JSON 格式的异常提示信息：

- 首先检查响应是否已经提交，如果已经提交，则直接返回一个空的 ModelAndView。
- 如果响应未提交，将重置响应对象，设置响应的内容类型为 JSON，并添加相关的响应头。
- 使用 response.getWriter() 将异常状态对象 errStatus 转换为 JSON 格式并写入响应。完成后，返回一个空的 ModelAndView。

②、如果是普通页面请求异常，代码会返回一个包含错误信息的 HTML 页面：

- 根据异常状态对象 errStatus 和响应对象 response 获取错误页面的视图名称。
- 创建一个 ModelAndView 对象，并设置视图名称。
- 设置响应的内容类型为 HTML。
- 向 ModelAndView 中添加全局属性、错误响应对象以及错误信息（以 JSON 格式）。
- 最后返回这个 ModelAndView 对象，用于展示错误页面。



其中 buildToastMsg 方法用来对异常进行分类，使用 instanceof 关键字来判断不同类型的异常，添加不同的异常码和提示消息。

```
private Status buildToastMsg(Exception ex) {
    if (ex instanceof ForumException) {
        return ((ForumException) ex).getStatus();
    } else if (ex instanceof AsyncRequestTimeoutException) {
        return Status.newStatus(StatusEnum.UNEXPECT_ERROR, "超时未登录");
    } else if (ex instanceof HttpMediaTypeNotAcceptableException) {
        return Status.newStatus(StatusEnum.RECORDS_NOT_EXISTS, ExceptionUtils.getStackTrace(ex));
    } else if (ex instanceof HttpRequestMethodNotSupportedException || ex instanceof MethodArgumentTypeMismatchException || ex instanceof IOException) {
        // 请求方法不匹配
        return Status.newStatus(StatusEnum.ILLEGAL_ARGUMENTS, ExceptionUtils.getStackTrace(ex));
    } else if (ex instanceof NestedRuntimeException) {
        log.error("unexpect NestedRuntimeException error! {}", ReqInfoContext.getReqInfo(), ex);
        return Status.newStatus(StatusEnum.UNEXPECT_ERROR, ex.getMessage());
    } else {
        log.error("unexpect error! {}", ReqInfoContext.getReqInfo(), ex);
        return Status.newStatus(StatusEnum.UNEXPECT_ERROR, ExceptionUtils.getStackTrace(ex));
    }
}
```



StatusEnum 中定义了异常码的规范

```
/**
 * 异常码规范：
 * xxx - xxx - xxx
 * 业务 - 状态 - code
 * <p>
 * 业务取值
 * - 100 全局
 * - 200 文章相关
 * - 300 评论相关
 * - 400 用户相关
 * <p>
 * 状态：基于http status的含义
 * - 4xx 调用方使用姿势问题
 * - 5xx 服务内部问题
 * <p>
 * code: 具体的业务code
 *
 * @author YiHui
 * @date 2022/7/27
 */
@Getter
public enum StatusEnum {
    SUCCESS(0, "OK"),

    // -------------------------------- 通用

    // 全局传参异常
    ILLEGAL_ARGUMENTS(100_400_001, "参数异常"),
    ILLEGAL_ARGUMENTS_MIXED(100_400_002, "参数异常:%s"),

    // 全局权限相关
    FORBID_ERROR(100_403_001, "无权限"),
}
```

getErrorPage 方法用于返回不同的错误页面，比如常见的 404 Not Found（请求的资源不存在，服务器无法找到请求的资源）、403 Forbidden（服务器理解请求，但是拒绝处理它，一般是由于权限问题或者访问被拒绝）、500 Internal Server Error（服务器发生了错误，无法完成请求）等。

```
private String getErrorPage(Status status, HttpServletResponse response) {
    // 根据异常码解析需要返回的错误页面
    if (StatusEnum.is5xx(status.getCode())) {
        response.setStatus(500);
        return "error/500";
    } else if (StatusEnum.is403(status.getCode())) {
        response.setStatus(403);
        return "error/403";
    } else {
        response.setStatus(404);
        return "error/404";
    }
}
```

restResponse 方法用来判断是否是 REST 请求，比如说 admin 后台请求、api 数据请求、上传图片等接口、Ajax 请求等，这些请求统一返回 JSON 格式的异常提示信息，否则返回普通的页面格式的异常提示信息。

```
/**
 * 后台请求、api数据请求、上传图片等接口，返回json格式的异常提示信息
 * 其他异常，返回500的页面
 *
 * @param request
 * @param response
 * @return
 */
private boolean restResponse(HttpServletRequest request, HttpServletResponse response) {
    if (request.getRequestURI().startsWith("/api/admin/") || request.getRequestURI().startsWith("/admin/")) {
        return true;
    }

    if (request.getRequestURI().startsWith("/image/upload")) {
        return true;
    }

    if (response.getContentType() != null && response.getContentType().contains(MediaType.APPLICATION_JSON_VALUE)) {
        return true;
    }

    if (isAjaxRequest(request)) {
        return true;
    }

    // 数据接口请求
    AntPathMatcher pathMatcher = new AntPathMatcher();
    if (pathMatcher.match("/**/api/**", request.getRequestURI())) {
        return true;
    }
    return false;
}

private boolean isAjaxRequest(HttpServletRequest request) {
    String requestedWith = request.getHeader("X-Requested-With");
    return "XMLHttpRequest".equals(requestedWith);
}
```



再来看一下自定义的异常类 ForumExceptio，继承了 RuntimeException。

    public class ForumAdviceException extends RuntimeException {
        @Getter
        private Status status;
    
        public ForumAdviceException(Status status) {
            this.status = status;
        }
    
        public ForumAdviceException(int code, String msg) {
            this.status = Status.newStatus(code, msg);
        }
    
        public ForumAdviceException(StatusEnum statusEnum, Object... args) {
            this.status = Status.newStatus(statusEnum, args);
        }
    
    }
    }



HandlerExceptionResolver 的工作原理主要基于 Spring MVC 的异常处理流程。当一个请求进入 Spring MVC 后，它会根据请求信息找到对应的处理器（handler，也就是 Controller）。在 Controller 执行过程中，如果抛出了异常，Spring MVC 就会启动异常处理流程。



1）异常发生：当 Controller 执行过程中抛出异常，Spring MVC 捕获到这个异常后，会进入异常处理流程。

2）查找异常解析器：Spring MVC 会遍历所有已注册的 HandlerExceptionResolver 实现。比如说我们自定义的 ForumExceptionHandler，Spring MVC 本身也提供了一些默认的实现，比如 DefaultHandlerExceptionResolver、ExceptionHandlerExceptionResolver。

3）执行异常解析器：对于每个 HandlerExceptionResolver 实现，Spring MVC 会调用它的 resolveException 方法，并传入请求、响应、处理器和异常对象。如果解析器能处理这个异常，它会返回一个非空的 ModelAndView 对象。这个对象封装了异常处理后的视图和模型数据。

4）处理返回结果：当 resolveException 方法返回一个非空的 ModelAndView 对象时，Spring MVC 会将这个对象用于生成最终的响应。可能渲染一个错误视图、设置响应状态码等。如果所有的 HandlerExceptionResolver 都无法处理这个异常（即都返回了空的 ModelAndView 对象），那么 Spring MVC 会将异常重新抛出，以便其他异常处理器（如 Servlet 容器）进行处理。

通过这个流程，HandlerExceptionResolver 能够在 Spring MVC 中统一管理和处理异常。记得在 Spring Boot 的启动类中将自定义的 HandlerExceptionResolver 添加到 Spring 配置中。

### @ControllerAdvice

除了 HandlerExceptionResolver，全局异常还可以采用 @ControllerAdvice  注解的方式。它可以将通用的操作和逻辑抽离出来，避免在每个控制器中重复相同的操作。 

第一步，新建一个自定义的异常类 ForumAdviceException。

第二步，新建一个全局异常控制器 GlobalExceptionHandler，内容如下所示。

```
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(value = ForumAdviceException.class)
    public ResVo<String> handleForumAdviceException(ForumAdviceException e) {
        return ResVo.fail(e.getStatus());
    }
}
```



@RestControllerAdvice  是一个特殊的 @ControllerAdvice  注解，适用于处理 RESTful API 异常的情况。这意味着它将用于处理来自带有 @RestController  注解的控制器抛出的异常。 

此类中定义的方法 handleForumAdviceException 使用 @ExceptionHandler  注解，表示它将处理 ForumAdviceException 类型的异常。 

第三步，加一个测试的控制器方法 testControllerAdvice。



两种全局异常处理的优缺点

好，我们来对比一下两种全局异常处理 HandlerExceptionResolver 和 @ControllerAdvice（或 @RestControllerAdvice）的优缺点。

①、HandlerExceptionResolver

HandlerExceptionResolver 是一个接口，用于处理由 Controller 抛出的异常，我们可以重写 resolveException 方法，在其中实现该接口来自定义全局异常处理逻辑。然后在 Spring Boot 的启动类中通过 extendHandlerExceptionResolvers 将自定义的 HandlerExceptionResolver 添加到解析器中。


优点：可以更加灵活地处理异常，因为你可以编写任何处理逻辑。

缺点：与其他 Spring MVC 组件的集成不够紧密，需要手动添加和配置。

②、@ControllerAdvice（或 @RestControllerAdvice）

@ControllerAdvice（或 @RestControllerAdvice）是用于定义全局异常处理类的注解。在这个类中，我们可以使用 @ExceptionHandler  注解来处理不同类型的异常。@ControllerAdvice  需要与 @ExceptionHandler  注解一起使用。 


优点：更容易实现和集成，只需创建一个带有 @ControllerAdvice（或 @RestControllerAdvice）注解的类，并使用 @ExceptionHandler  注解定义异常处理方法。 

缺点：异常处理逻辑可能不如 HandlerExceptionResolver 那么灵活。

我们可以根据具体的需求和使用场景，选择其中之一来实现全局异常处理。



## 网页使用之如何返回json/xml



 

>  [【WEB系列】返回文本、网页、图片的操作姿势 | 一灰灰Blog](https://spring.hhui.top/spring-blog/2019/09/13/190913-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8B%E8%BF%94%E5%9B%9E%E6%96%87%E6%9C%AC%E3%80%81%E7%BD%91%E9%A1%B5%E3%80%81%E5%9B%BE%E7%89%87%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A7%BF%E5%8A%BF/)  
>
> [【WEB系列】xml传参与返回使用姿势 | 一灰灰Blog](https://spring.hhui.top/spring-blog/2020/07/06/200706-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8Bxml%E4%BC%A0%E5%8F%82%E4%B8%8E%E8%BF%94%E5%9B%9E%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/) 

